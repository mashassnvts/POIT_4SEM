#include "BFS.h" // Подключаем заголовочный файл "BFS.h"

// Метод инициализации обхода в ширину
void BFS::init(const graph::AList& al, int s)
{
    // Устанавливаем указатель на переданный список смежности
    this->al = &al;

    // Выделяем память под массивы цветов, расстояний и предшествующих вершин
    this->c = new Color[this->al->n_vertex]; // Массив цветов вершин
    this->d = new int[this->al->n_vertex];   // Массив расстояний от начальной вершины
    this->p = new int[this->al->n_vertex];   // Массив предшествующих вершин

    // Инициализируем все вершины как не посещенные
    for (int i = 0; i < this->al->n_vertex; i++)
    {
        this->c[i] = WHITE; // WHITE - не посещена
        this->d[i] = INF;   // INF - бесконечное расстояние (не достижима)
        this->p[i] = NIL;   // NIL - отсутствие предшествующей вершины
    }

    // Начальная вершина s помечается как посещенная (GRAY) и добавляется в очередь
    this->c[s] = GRAY; // GRAY - посещена, но не обработана
    this->q.push(s);  // Добавляем начальную вершину в очередь обхода
}

// Конструктор для списка смежности
BFS::BFS(const graph::AList& al, int s)
{
    // Вызываем метод инициализации для заданного списка смежности и начальной вершины
    this->init(al, s);
}

// Конструктор для матрицы смежности
BFS::BFS(const graph::AMatrix& am, int s)
{
    // Создаем новый список смежности из матрицы и вызываем метод инициализации
    this->init(*(new graph::AList(am)), s);
}

// Метод для получения следующей вершины в обходе в ширину
int BFS::get()
{
    int rc = NIL, v = NIL; // Переменные для текущей вершины (rc) и смежной вершины (v)

    if (!this->q.empty()) // Если очередь не пуста
    {
        rc = this->q.front(); // Берем первую вершину из очереди
        for (int j = 0; j < this->al->size(rc); j++) // Цикл по всем смежным вершинам текущей вершины rc
        {
            if (this->c[v = this->al->get(rc, j)] == WHITE) // Если смежная вершина v белая (не посещена)
            {
                this->c[v] = GRAY;          // Помечаем ее как посещенную, но не обработанную
                this->d[v] = this->d[rc] + 1; // Устанавливаем расстояние до нее на 1 больше, чем до текущей
                this->p[v] = rc;             // Устанавливаем текущую вершину rc как предшествующую для v
                this->q.push(v);             // Добавляем v в очередь для дальнейшей обработки
            }
        }

        this->q.pop();       // Удаляем текущую вершину из очереди, так как ее обработка завершена
        this->c[rc] = BLACK; // Помечаем текущую вершину как обработанную (черная)
    }

    return rc; // Возвращаем текущую вершину для обработки на данном шаге
}
