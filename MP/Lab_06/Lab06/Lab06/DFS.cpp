#include "DFS.h" // Подключаем заголовочный файл "DFS.h"

#define NINF 0x80000000 // Определяем значение для отрицательной бесконечности
#define INF  0x7fffffff // Определяем значение для положительной бесконечности

// Метод инициализации обхода в глубину
void DFS::init(const graph::AList& al)
{
	// Устанавливаем указатель на переданный список смежности
	this->al = &al;

	// Выделяем память под массивы цветов, времен открытия и закрытия, предшествующих вершин
	this->c = new Color[this->al->n_vertex]; // Массив цветов вершин
	this->d = new int[this->al->n_vertex];   // Массив времен открытия вершин
	this->f = new int[this->al->n_vertex];   // Массив времен закрытия вершин
	this->p = new int[this->al->n_vertex];   // Массив предшествующих вершин
	this->t = 0; // Инициализируем счетчик времени обхода

	// Инициализируем все вершины как не посещенные
	for (int i = 0; i < this->al->n_vertex; i++)
	{
		this->c[i] = WHITE; // WHITE - не посещена
		this->d[i] = this->f[i] = 0; // Обнуляем времена открытия и закрытия
		this->p[i] = NIL; // NIL - отсутствие предшествующей вершины
	}

	// Выполняем обход для всех вершин, если они еще не посещены
	for (int i = 0; i < this->al->n_vertex; i++)
	{
		if (this->c[i] == WHITE) // Если вершина не посещена
		{
			this->visit(i); // Вызываем метод обхода для данной вершины
			this->topological_sort.push_back(i); // Добавляем вершину в топологическую сортировку
		}
	}
}

// Конструктор для списка смежности
DFS::DFS(const graph::AList& al)
{
	// Вызываем метод инициализации для заданного списка смежности
	this->init(al);
}

// Конструктор для матрицы смежности
DFS::DFS(const graph::AMatrix& am)
{
	// Создаем новый список смежности из матрицы и вызываем метод инициализации
	this->init(*(new graph::AList(am)));
}

// Метод обхода в глубину для вершины u
void DFS::visit(int u)
{
	int v = NIL; // Переменная для смежной вершины
	this->c[u] = GRAY; // Помечаем текущую вершину как посещенную, но не обработанную
	this->d[u] = ++(this->t); // Устанавливаем время открытия вершины
	for (int j = 0; j < this->al->size(u); j++) // Цикл по всем смежным вершинам текущей вершины u
	{
		if (this->c[v = this->al->get(u, j)] == WHITE) // Если смежная вершина v белая (не посещена)
		{
			this->p[v] = u; // Устанавливаем текущую вершину u как предшествующую для v
			this->visit(v); // Рекурсивно вызываем обход для вершины v
			this->topological_sort.push_back(v); // Добавляем вершину v в топологическую сортировку
		}
	}
	this->c[u] = BLACK; // Помечаем текущую вершину как обработанную
	this->f[u] = ++(this->t); // Устанавливаем время закрытия вершины
}

// Метод для получения вершины по времени f[i] (топологическая сортировка)
int DFS::get(int i)
{
	int j = 0, min1 = INF, min2 = NINF, ntx = NIL; // Переменные для поиска вершины с минимальным временем закрытия
	for (int j = 0; j <= i; j++)
	{
		for (int k = 0; k < this->al->n_vertex; k++) // Цикл по всем вершинам
		{
			if (this->f[k] < min1 && this->f[k] > min2) // Если время закрытия вершины k меньше min1 и больше min2
			{
				min1 = this->f[k]; // Обновляем min1
				ntx = k;           // Устанавливаем новую вершину с минимальным временем закрытия
			}
		}
		min2 = min1;  // Обновляем второе минимальное время
		min1 = INF;   // Сбрасываем первое минимальное время
	}
	return ntx; // Возвращаем вершину с минимальным временем закрытия
}
